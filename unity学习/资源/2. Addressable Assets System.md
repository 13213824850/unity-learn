### 一、核心定义：它是什么？

**Addressable Assets System** 是 Unity 官方推出的新一代**资源管理系统**。它的核心思想是：**让资源加载变得简单、高效、可扩展，无论资源在何处。**

你可以把它理解为 AssetBundle 系统的“超级进化版”，它底层仍然使用 AssetBundle 技术，但为开发者提供了一个更高级、更易用、功能更强大的封装。

**核心概念**：每个资源都有一个唯一的**地址**，你只需要通过这个地址来加载资源，而无需关心这个资源到底在哪里、如何被打包、是本地还是远程的。

---

### 二、为什么需要它？要解决什么问题？

在 Addressable 系统出现之前，Unity 开发者管理资源的方式主要有以下几种，但它们都有明显的缺点：

1. **Resources 文件夹**：
    
    - **缺点**：所有资源都打包在主程序中，无法更新，导致初始包体巨大。内存管理不灵活，卸载麻烦。
        
2. **直接使用 AssetBundle**：
    
    - **缺点**：**极其复杂**！开发者需要手动处理：
        
        - 资源的依赖关系。
            
        - AssetBundle 的打包、上传、版本管理。
            
        - 复杂的加载和卸载逻辑，容易导致内存泄漏或资源丢失。
            
        - 本地和远程资源的差异化处理。
            

**Addressable 系统就是为了解决上述所有痛点而生的。**

---

### 三、核心工作流程

#### 1. **标记资源 - “赋予地址”**

在 Inspector 窗口，将资源的 “Addressable” 勾选上，并为其设置一个唯一的地址。  
这个地址就是未来加载资源时使用的“钥匙”。

#### 2. **组织资源 - “分组管理”**

在 Addressables Groups 窗口中，你可以看到所有被标记的资源。你可以创建不同的组来管理资源。

- **本地组**：包含随应用安装的资源。
    
- **远程组**：包含存放在服务器上，需要时再下载的资源。  
    你可以为每个组设置不同的打包策略、压缩方式等。
    

#### 3. **构建 - “生成交付物”**

构建时，Addressable 系统会自动：

- 分析资源之间的依赖关系。
	 
```
	假设: Player.prefab -> HeroMat.mat -> HeroTex.png
	// 2. 构建系统会自动：
//    - 发现 Player.prefab 依赖 HeroMat.mat
//    - 发现 HeroMat.mat 依赖 HeroTex.png
//    - 自动将这三个资源合理打包（可能在一个包，也可能在多个包）
//    - 在目录中记录完整的依赖关系

注释：如果是策划配表去关联资源关系 需要打包脚本自己去处理依赖关联 退化到ab包的依赖管理
```
    
- 根据分组设置，将资源打包成 AssetBundle。
    
- 为本地资源生成构建结果。
    
- 为远程资源生成需要上传到服务器（如 CDN）的文件和一个内容目录文件。
    

#### 4. **运行时加载 - “通过地址获取”**

在游戏代码中，你只需要关心资源的**地址**。

**基础加载示例：**

csharp

using UnityEngine;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

public class LoadAddressable : MonoBehaviour
{
    // 方法一：通过字符串地址异步加载
    public void LoadWithString(string address)
    {
        Addressables.LoadAssetAsync<GameObject>(address).Completed += OnLoadDone;
    }

    // 方法二：通过 AssetReference 在 Inspector 中拖拽引用（类型安全，推荐！）
    public AssetReference myPrefabReference;

    public void LoadWithReference()
    {
        myPrefabReference.LoadAssetAsync<GameObject>().Completed += OnLoadDone;
    }

    private void OnLoadDone(AsyncOperationHandle<GameObject> handle)
    {
        if (handle.Status == AsyncOperationStatus.Succeeded)
        {
            GameObject loadedObject = handle.Result;
            Instantiate(loadedObject, transform.position, Quaternion.identity);
        }
        else
        {
            Debug.LogError($"Failed to load asset: {handle.OperationException}");
        }
    }
}

---

### 四、核心特性与巨大优势

1. **基于地址的加载**
    
    - **优势**：将资源逻辑与物理位置解耦。你可以轻松地将一个资源从本地移动到远程，而**无需修改任何加载代码**，只需要重新构建即可。
        
2. **强大的内存管理**
    
    - **自动引用计数**：系统会跟踪每个资源被加载了多少次。只有当引用计数降为 0 时，资源才会被安全地卸载。这从根本上解决了 AssetBundle 手动卸载的难题。
        
3. **简化的打包与部署**
    
    - 系统自动处理复杂的依赖关系，你不再需要手动编写脚本去分析依赖。
        
    - 提供清晰的界面来区分本地和远程资源。
        
4. **无缝的热更新**
    
    - 这是它的杀手级功能。当你更新远程资源后，重新构建并上传到服务器。玩家再次启动游戏时，系统会**自动检查内容目录的更新**，并只下载发生变化的资源包，实现无缝热更。
        
5. **内容分发**
    
    - 可以轻松制作 DLC 或按需下载特定内容包（例如，只为购买了某个角色的玩家下载该角色的资源）。
        
6. **出色的开发体验**
    
    - **Play Mode Scripts**：允许你在编辑器模式下模拟不同的资源加载场景（如纯本地模式、模拟从服务器加载模式），极大提升开发效率。
        

---

### 五、Addressable 与 AssetBundle 的关系

这是一个非常重要的理解点：

|特性|AssetBundle (传统方式)|Addressable Assets System|
|---|---|---|
|**本质**|**底层技术**|**上层架构和工作流**|
|**加载方式**|通过文件路径和 Bundle 名|通过**逻辑地址**|
|**依赖管理**|手动，通过 `AssetBundleManifest`|**全自动**，系统处理|
|**内存管理**|手动调用 `Unload(true/false)`|**自动引用计数**|
|**热更新**|需要自己实现全套版本管理和差分更新逻辑|**内置支持**，配置简单|
|**开发复杂度**|**高**，容易出错|**低**，流程标准化|

**结论**：Addressable 系统 **使用** AssetBundle 作为其分发和打包的格式，但为你隐藏了所有复杂的管理工作。**对于新项目，应毫不犹豫地选择 Addressable。**

---

### 总结

**Unity 的 Addressable Assets System 是一个现代化的、强大的资源管理解决方案。它将开发者从繁琐的底层资源管理中解放出来，通过“地址”这一核心概念，实现了资源的无缝定位、加载、更新和内存管理，是开发现今复杂游戏和应用不可或缺的工具。**