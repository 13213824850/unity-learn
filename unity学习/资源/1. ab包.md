# 1. ab包
### 一、AssetBundle 是什么？

**核心定义**：AssetBundle 是一个存档文件，包含你在 Unity 项目中创建的资源，如模型、纹理、预制体、音效、甚至整个场景。这些文件在构建时生成，在运行时由 Unity 应用程序按需下载和加载。

**简单比喻**：

- **主程序**：就像一个书架，本身是空的。
    
- **AssetBundle**：就像一本本可以随时从服务器或本地取来，放到书架上阅读的书。
    

---

### 二、为什么需要使用 AssetBundle？主要优势

1. **减少初始安装包大小**
    
    - 将非核心资源（如过场动画、高清贴图、非首日内容）放到服务器上，玩家进入游戏后再下载，显著降低 App Store 或 Google Play 上的初始下载体积。
        
2. **热更新 / 动态资源更新**
    
    - 这是最核心的用途之一。你可以修复一个 BUG、替换一个 UI 图片、调整一个角色的数值，而无需让玩家重新下载整个游戏。只需要更新服务器上的 AssetBundle 文件即可。
        
3. **管理可下载内容**
    
    - 为游戏添加 DLC，如新关卡、新角色、新剧情。将这些新内容打包成 AssetBundle，玩家购买后下载即可体验。
        
4. **特定平台资源管理**
    
    - 虽然 Unity 本身有平台差异化设置，但使用 AssetBundle 可以更灵活。例如，你可以为高端机和低端机准备不同精度的资源包，让玩家根据自己设备选择下载。
        
5. **内存管理优化**
    
    - 可以更精细地控制资源的加载和卸载时机，在不需要时彻底释放资源，避免内存浪费。
        

---

### 三、AssetBundle 的核心工作流程

AssetBundle 的使用分为三个主要阶段：**构建**、**分发**、**加载**。

#### 阶段一：构建

在 Unity Editor 中，你将资源打包成 `.ab` 文件。

1. **标记资源**：在 Inspector 窗口底部，为资源设置 AssetBundle 名称和变体。
    
2. **构建脚本**：编写一个 Editor 脚本，调用 `BuildPipeline.BuildAssetBundles` API 来执行打包操作。
    
    csharp
    
    using UnityEditor;
    using System.IO;
    
    public class CreateAssetBundles
    {
        [MenuItem("Assets/Build AssetBundles")]
        static void BuildAllAssetBundles()
        {
            string outputPath = "Assets/AssetBundles";
            if (!Directory.Exists(outputPath))
                Directory.CreateDirectory(outputPath);
    
            // 参数：输出路径、构建选项、目标平台
            BuildPipeline.BuildAssetBundles(outputPath, 
                                            BuildAssetBundleOptions.ChunkBasedCompression, 
                                            BuildTarget.Android);
        }
    }
    
    - **构建选项**：如 `ChunkBasedCompression` 在压缩率和加载速度间取得了良好平衡。
        

#### 阶段二：分发

将构建出的 AssetBundle 文件上传到某个地方，供游戏客户端下载。

- **本地**：放在 `StreamingAssets` 文件夹中，随包发布。
    
- **远程服务器**：上传到 CDN 或 Web 服务器，这是热更新的前提。
    

#### 阶段三：运行时加载

在游戏运行时，从本地或网络下载并加载 AssetBundle 中的资源。

1. **下载 / 加载 AssetBundle**
    
    - **从远程服务器**：使用 `UnityWebRequestAssetBundle`
        
    
    csharp
    
    IEnumerator LoadBundleFromWeb(string bundleUrl)
    {
        using (UnityWebRequest webRequest = UnityWebRequestAssetBundle.GetAssetBundle(bundleUrl))
        {
            yield return webRequest.SendWebRequest();
    
            if (webRequest.result != UnityWebRequest.Result.Success)
            {
                Debug.LogError(webRequest.error);
            }
            else
            {
                // 从下载结果中获取 AssetBundle
                AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(webRequest);
                // 然后从 bundle 中加载资源
                GameObject prefab = bundle.LoadAsset<GameObject>("MyObject");
                Instantiate(prefab);
            }
        }
    }
    
    - **从本地文件**：使用 `AssetBundle.LoadFromFile`
        
    
    csharp
    
    AssetBundle localBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, "mybundle"));
    GameObject prefab = localBundle.LoadAsset<GameObject>("MyObject");
    Instantiate(prefab);
    
2. **管理依赖**
    
    - 一个 AssetBundle 中的资源可能引用另一个 AssetBundle 中的资源。构建时会生成一个**主清单**文件，其中记录了所有依赖信息。
        
    - 加载时，需要先加载所有依赖的 Bundle，再加载目标资源。
        
    
    csharp
    
    // 1. 加载主清单（通常随第一个加载的Bundle或单独获取）
    AssetBundle manifestBundle = AssetBundle.LoadFromFile(manifestPath);
    AssetBundleManifest manifest = manifestBundle.LoadAsset<AssetBundleManifest>("AssetBundleManifest");
    
    // 2. 获取目标Bundle的所有依赖项名称
    string[] dependencies = manifest.GetAllDependencies("ui.bundle");
    
    // 3. 加载所有依赖项
    foreach(string dependency in dependencies)
    {
        AssetBundle.LoadFromFile(Path.Combine(bundlePath, dependency));
    }
    
    // 4. 现在可以安全地加载目标Bundle和其中的资源了
    AssetBundle uiBundle = AssetBundle.LoadFromFile(Path.Combine(bundlePath, "ui.bundle"));
    
3. **卸载**
    
    - **`AssetBundle.Unload(false)`**：卸载 AssetBundle 文件镜像，但保留已加载出的资源实例。可能导致资源重复。
        
    - **`AssetBundle.Unload(true)`**：卸载 AssetBundle 文件镜像，并**销毁**所有从其加载出的资源实例。这是最安全、最常用的方式，但需要确保这些资源已不再被使用。
        
    - **`Resources.UnloadUnusedAssets()`**：配合 `Unload(false)` 使用，卸载所有不再被引用的资源。
        

---

### 四、AssetBundle 的挑战与最佳实践

1. **依赖管理**：依赖关系处理不当是导致资源丢失或重复的常见原因。务必使用 `AssetBundleManifest` 来正确处理依赖。
    
2. **内存管理**：不正确的卸载会导致内存泄漏或资源丢失。制定清晰的加载/卸载策略，通常 `Unload(true)` 是更安全的选择。
    
3. **版本管理与热更新**：
    
    - 使用 **MD5 Hash** 或 **CRC** 校验文件完整性。
        
    - 使用**清单文件**记录服务器上所有 AssetBundle 的版本信息，客户端对比本地清单，决定需要下载哪些更新。
        
4. **打包策略**：
    
    - **按逻辑类型打包**：所有 UI 打一个包，所有角色打一个包。简单但粒度粗。
        
    - **按功能/场景打包**：一个关卡或一个系统的所有资源打一个包。粒度适中，常用。
        
    - **按共享资源打包**：将高频共享的资源单独打包，避免重复。
        
5. **压缩策略**：
    
    - **LZMA**：高压缩率，但加载前需整体解压。适合下载。
        
    - **LZ4**：压缩率较低，但支持随机读取，无需整体解压。适合本地存储或对加载速度要求高的场景。
        
    - **不压缩**：加载最快，但文件体积最大。
# aab

1. 
